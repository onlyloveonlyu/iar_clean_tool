# !/usr/bin/python3# -*- coding: utf-8 -*-import sysimport osimport shutilimport zipfileimport ctypesimport cmdglobal current_dirglobal target_dirdef run_as_admin():    """    Get administrator permissions for scripts in Windows system    :return: Bool. get permission or not    """    if os.name != 'nt':        return True    if not ctypes.windll.shell32.IsUserAnAdmin():        if sys.version_info[0] == 3:  # Python3            ret = ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, __file__, None, 1)        else:  # Python2            ret = ctypes.windll.shell32.ShellExecuteW(None, u"runas", unicode(sys.executable),                                                      unicode(__file__), None, 1)        if ret <= 32:            return False        exit(0)  # Close self because the UAC will start mirror    return Truedef error_output(strings):    input(strings)    sys.stderr.write(strings)    exit(1)def folder_size_get(path, size=0):    """    Get 'path' usage disk size    :param path: path    :param size: skip    :return: size bytes    """    for root, dirs, files in os.walk(path):        for f in files:            size += os.path.getsize(os.path.join(root, f))    return sizedef folder_list_get(path, ignore: list):    """    get the sub-folder name list of 'path'    :param path:  to search path    :param ignore: list. ignore folder names    :return: list    """    dir_list = list(filter(lambda x: os.path.isdir(os.path.join(path, x)), os.listdir(path)))    for item in ignore:        if item in dir_list:            dir_list.remove(item)    dir_list.sort()    return dir_list# noinspection SpellCheckingInspectiondef command_config_size(src_path, dst_path):    """    Show the size of the device config folder in iar installation directory    Show the free size of user directory    :param src_path:    iar install path    :param dst_path:    user path    :return:    None    """    src_path = os.path.join(src_path, 'arm', 'config')    print('src/debugger:{:6.2f}MB'.format(folder_size_get(os.path.join(src_path, 'debugger')) / (1024 ** 2)))    print('src/devices :{:6.2f}MB'.format(folder_size_get(os.path.join(src_path, 'devices')) / (1024 ** 2)))    print('src/flashld :{:6.2f}MB'.format(folder_size_get(os.path.join(src_path, 'flashloader')) / (1024 ** 2)))    print('src/linker  :{:6.2f}MB'.format(folder_size_get(os.path.join(src_path, 'linker')) / (1024 ** 2)))    print('dst free    :{:6.2f}GB'.format(shutil.disk_usage(dst_path).free / (1024 ** 3)))def list_string_item_match(inlist: list, strings):    """    Match string item in the list    :param inlist:  input list    :param strings: match string    :return: item in list    """    if not strings:        return ''    if len(inlist) == 0:        return ''    device = [dev for dev in inlist if dev.lower().startswith(strings.lower())]    if len(device) == 1:  # only one matched        return device[0]    elif len(device) == 0:        return ''    else:        print("AutoMatch:")        for index in range(len(device)):            print('\t', index, device[index])        user_input = input("Enter selection number: ")        if not user_input.isdigit():            print("!!!Wrong number!!!", user_input)            return ''        user_input = int(user_input)        if user_input >= len(device):            print("!!!Large number!!!", user_input)            return ''        return device[user_input]def command_devices_list(src_path):    """    Show list of iar inside devices    :param src_path: iar install root dir    :return: None    """    src_path = os.path.join(src_path, 'arm', 'config', 'devices')    devices_list = folder_list_get(src_path, ['ARM'])    print('DevicesNum:', len(devices_list))    for index in range(len(devices_list)):        if index % 4 == 0 and index != 0:            print('')        print('{:24s} '.format(devices_list[index]), end='')    print('')def command_exec_move(src_path, dst_path, name):    """    move iar config to user path    :param src_path: iar install path    :param dst_path: user path    :param name: manufacturer    :return: bool success or fail    """    device_name = list_string_item_match(folder_list_get(os.path.join(src_path, 'arm', 'config', 'devices'), ['ARM']),                                         name)    if len(device_name) == 0:        print('Please check manufacturer name.')        return False    print('Manufacturer name:', device_name)    path_list = [os.path.join('devices', device_name), os.path.join('debugger', device_name),                 os.path.join('flashloader', device_name), os.path.join('linker', device_name)]    # move path    for path in path_list:        source_path = os.path.join(src_path, 'arm', 'config', path)        target_path = os.path.join(dst_path, device_name, 'arm', 'config', path)        if not os.path.exists(source_path):            print('Source path not exists:', path)            continue        if not os.access(source_path, os.R_OK | os.W_OK | os.X_OK):            print('Source path access failed:', path)            continue        # Check target path        if not os.path.exists(target_path):            os.makedirs(target_path)        else:            shutil.rmtree(target_path)  # Clear last buffer            print('Move target path clean.', path)        # Move files        try:            # shutil.copytree(src_path, dst_path) # Only copy folder.don't makedir before            shutil.move(source_path, target_path)        except BaseException as e:            print('Move failed', path, e)    # Maker zip    # ret = shutil.make_archive(os.path.join(dst_path, 'backup', device_name), 'zip',    #                           os.path.join(dst_path, device_name))    # print('Move make archive:', ret)    # shutil.rmtree(os.path.join(dst_path, device_name))    print('Move %s success.' % device_name)    return Truedef command_exec_zip(src_path, dst_path, name):    """    make zip file from IAR config folder    :param src_path: iar install path    :param dst_path: user path    :param name: manufacturer    :return: bool success or fail    """    device_name = list_string_item_match(folder_list_get(os.path.join(src_path, 'arm', 'config', 'devices'), ['ARM']),                                         name)    if len(device_name) == 0:        print('Please check manufacturer name.')        return False    print('Manufacturer name:', device_name)    path_list = [os.path.join('devices', device_name), os.path.join('debugger', device_name),                 os.path.join('flashloader', device_name), os.path.join('linker', device_name)]    # Zip path    zip_data = zipfile.ZipFile(os.path.join(dst_path, 'backup', device_name) + '.zip', 'w', zipfile.ZIP_DEFLATED)    for path in path_list:        source_path = os.path.join(src_path, 'arm', 'config', path)        if not os.path.exists(source_path):            print('Source path not exists:', path)            continue        if not os.access(source_path, os.R_OK | os.W_OK | os.X_OK):            print('Source path access failed:', path)            continue        for root, dirs, files in os.walk(source_path):            relative_path = root.replace(src_path, '')            relative_path = relative_path and relative_path + os.sep or ''            for filename in files:                zip_data.write(os.path.join(root, filename), os.path.join(relative_path, filename))    zip_data.close()    print('Zip %s success.' % device_name)    print('Zip size %6.2fMB.' % (os.path.getsize(os.path.join(dst_path, 'backup', device_name) + '.zip') / (1024 ** 2)))    return Truedef command_exec_del(src_path, name):    """    Delete iar config folder    :param src_path: iar install path    :param name: manufacturer    :return: bool success or fail    """    device_name = list_string_item_match(folder_list_get(os.path.join(src_path, 'arm', 'config', 'devices'), ['ARM']),                                         name)    if len(device_name) == 0:        print('Please check manufacturer name.')        return False    print('Manufacturer name:', device_name)    path_list = [os.path.join('devices', device_name), os.path.join('debugger', device_name),                 os.path.join('flashloader', device_name), os.path.join('linker', device_name)]    # Delete path    for path in path_list:        source_path = os.path.join(src_path, 'arm', 'config', path)        if not os.path.exists(source_path):            print('Source path not exists:', path)            continue        if not os.access(source_path, os.R_OK | os.W_OK | os.X_OK):            print('Source path access failed:', path)            continue        # Delete files        try:            shutil.rmtree(source_path)        except BaseException as e:            print('Delete failed', path, e)    print('Delete %s success.' % device_name)    return Truedef command_complete(src_path, strings):    """    Auto complete manufacturer names    :param src_path: iar install path    :param strings:  user input chars    :return:    """    devices = folder_list_get(os.path.join(src_path, 'arm', 'config', 'devices'), ['ARM'])    if not strings:  # 列出可选参数        return devices    else:        return [i for i in devices if i.lower().startswith(strings.lower())]def tool_header_show(src_path, dst_path):    print('==IAR Clean Tool==')    print('Current:', src_path)    print('Target :', dst_path)    print('Total:{:6.2f}GB '.format(shutil.disk_usage(dst_path).total / (1024 ** 3)), end='')    print('Free:{:6.2f}GB'.format(shutil.disk_usage(dst_path).free / (1024 ** 3)))# noinspection SpellCheckingInspectionclass cmd_core(cmd.Cmd):    def __init__(self):        cmd.Cmd.__init__(self)        self.prompt = '>'        self.doc_leader = "==IAR Clear Tool Help Information=="        self.doc_header = "example:\n" \                          "zip ST # compress ST devices configuration for backup\n" \                          "del ST # delete ST devices configuration for free space"        tool_header_show(current_dir, target_dir)    def do_size(self, arg):        self.prompt = '>'        command_config_size(current_dir, target_dir)    def help_size(self):        self.prompt = '>'        print('Show IAR device config path size.')        print('This will take some time.')    def do_list(self, arg):        self.prompt = '>'        command_devices_list(current_dir)    def help_list(self):        self.prompt = '>'        print("Show IAR support devices list.")    def do_move(self, arg):        self.prompt = '>'        if run_as_admin():            command_exec_move(current_dir, target_dir, arg)    def help_move(self):        self.prompt = '>'        print("Move IAR devices config to user path.")        print("Usage: move [manufacturer]")    def complete_move(self, text, line, begidx, endidx):        self.prompt = '>'        return command_complete(current_dir, text)    def do_zip(self, arg):        self.prompt = '>'        command_exec_zip(current_dir, target_dir, arg)    def help_zip(self):        self.prompt = '>'        print("Compress IAR devices config to user path.")        print("Usage: zip [manufacturer]")    def complete_zip(self, text, line, begidx, endidx):        self.prompt = '>'        return command_complete(current_dir, text)    def do_del(self, arg):        self.prompt = '>'        if run_as_admin():            command_exec_del(current_dir, arg)    def help_del(self):        self.prompt = '>'        print("Delete IAR devices config.")        print("Usage: del [manufacturer]")    def complete_del(self, text, line, begidx, endidx):        self.prompt = '>'        return command_complete(current_dir, text)    def do_clear(self, arg):        self.prompt = '>'        if os.name == 'nt':            os.system('cls')        else:            os.system('clear')        tool_header_show(current_dir, target_dir)    def help_clear(self):        pass    # def preloop(self):    #     print("PreLoop")    # def postloop(self):    #     print("PostLoop")    # def emptyline(self):    # User input empty    #     pass    # def default(self, line):    #     print("Unknow Command.", line)    def do_exit(self, arg):        self.prompt = '>'        return True    def help_exit(self):        passif __name__ == '__main__':    current_dir = "C:\\Program Files\\IAR Systems\\Embedded Workbench 9.1"    if 'current_dir' not in dir():        current_dir = sys.path[0]  # don't use os.getcwd()    target_dir = os.path.expanduser('~\\Documents')    # Command line input target dir    if len(sys.argv) >= 2:        if os.path.isdir(sys.argv[1]):            current_dir = sys.argv[1]    if len(sys.argv) >= 3:        if os.path.isdir(sys.argv[2]):            target_dir = sys.argv[2]    for dir_name in ['debugger', 'devices', 'flashloader', 'linker']:        dir_address = os.path.join(current_dir, 'arm', 'config', dir_name)        if not os.path.exists(dir_address):            error_output('Root address check failed.' + dir_address)    # Get admin    # if not run_as_admin():    #     error_output("Obtain permissions failed.")    # Bash    cli = cmd_core()    cli.cmdloop()